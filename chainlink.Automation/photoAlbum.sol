// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.0.0
pragma solidity ^0.8.27;

import {AutomationCompatibleInterface } from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import {ERC721URIStorage} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {Counters} from "@openzeppelin/contracts@4.6.0/utils/Counters.sol";

contract Photoalbum is ERC721, ERC721Enumerable, ERC721URIStorage,AutomationCompatibleInterface ,Ownable {
    using Counters for Counters.Counter;
    
    Counters.Counter public tokenIdCounter;    

    uint public immutable interval;
    uint public lastTimeStamp;


    string[] IpfsUri = [
        "https://ipfs.io/ipfs/QmcusKgN4XKSLcJjHD9WF7WAuww6mmcGUkUWKgQsXhW7vA/photo01.json",
        "https://ipfs.io/ipfs/QmcusKgN4XKSLcJjHD9WF7WAuww6mmcGUkUWKgQsXhW7vA/photo02.json",
        "https://ipfs.io/ipfs/QmcusKgN4XKSLcJjHD9WF7WAuww6mmcGUkUWKgQsXhW7vA/photo03.json"
    ];
    
    constructor(uint256 updateInterval)
        ERC721("photoalbum", "PAm")
        Ownable(msg.sender)
    {
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
    }

    function safeMint(address to)
        public
        onlyOwner
        returns (uint256)
    {
        uint256 tokenId = tokenIdCounter.current();
        tokenIdCounter.increment();
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, IpfsUri[0]);
        return tokenId;
    }

    function compareStrings(string memory a , string memory b) internal pure returns(bool){
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    } 

    function photoAlbumIndex(uint256 tokenId) public view returns(uint){
        string memory uri = tokenURI(tokenId);

        if(compareStrings(uri , IpfsUri[0])){
            return 0;
        }
        if(compareStrings(uri , IpfsUri[1])){
            return 1;
        }
        
        return 2;
    }

    function rotatePhoto(uint256 tokenId) public{
        if(photoAlbumIndex(tokenId) >= 2){return;} 

        uint256 newval = photoAlbumIndex(tokenId) + 1;
        string memory newuri = IpfsUri[newval];
        _setTokenURI(tokenId,newuri);
    }

    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        if ((block.timestamp - lastTimeStamp) > interval ) {
            uint256 tokenId = tokenIdCounter.current() - 1;
            if (photoAlbumIndex(tokenId) < 2) {
                upkeepNeeded = true;
            }
        }
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            uint256 tokenId = tokenIdCounter.current() - 1;
            if (photoAlbumIndex(tokenId) < 2) {
                lastTimeStamp = block.timestamp;            
                rotatePhoto(tokenId);
            }
        }
        // We don't use the performData in this example. The performData is generated by the Automation's call to your checkUpkeep function
    }


    // The following functions are overrides required by Solidity.

    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721, ERC721Enumerable)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    function _increaseBalance(address account, uint128 value)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._increaseBalance(account, value);
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
